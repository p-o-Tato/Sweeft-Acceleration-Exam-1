# დავაიმპორტოთ ჩემი საყვარელი ბიბლიოთეკა
import math

# 1. გვაქვს 1,5,10,20 და 50 თეთრიანი მონეტები. დაწერეთ ფუნქცია,
# რომელსაც გადაეცემა თანხა (თეთრებში) და აბრუნებს მონეტების მინიმალურ რაოდენობას,
# რომლითაც შეგვიძლია ეს თანხა დავახურდაოთ.

def minSplit(amount):
    nominals = [50, 20, 10, 5, 1]
    res = amount
    cnt = 0
    for i in range(5):
        cnt += math.floor(res / nominals[i])
        res = res % nominals[i]
    return cnt


# 2. დაწერეთ ფუნქცია რომელიც დააჯამებს ციფრებს ორ რიცსხვს შორის.

def sum_digits(n):
    sum = 0
    while n:
        sum += n % 10
        n //= 10
    return sum

def sumOfDigits(start, end):
    sum = 0
    for i in range(start,end+1):
        sum += sum_digits(i)
    return sum


# 3. მოცემულია String რომელიც შედგება „(" და „)" ელემენტებისგან.
# დაწერეთ ფუნქცია რომელიც აბრუნებს ფრჩხილები არის თუ არა მათემატიკურად სწორად დასმული.

def isProperly(sequence):
    cnt = 0
    for ch in sequence:
        if ch == "(":
            cnt += 1
        else:
            cnt -= 1
        if cnt < 0:
            return False
    return cnt == 0

# 4. გვაქვს N ფიცრისგან შემდგარი ხიდი. სიძველის გამო ზოგიერთი ფიცარი ჩატეხილია.
# ზურიკოს შეუძლია გადავიდეს შემდეგ ფიცარზე ან გადაახტეს ერთ ფიცარს. (რათქმაუნდა ჩატეხილ ფიცარზე ვერ გადავა)
# ჩვენი ამოცანაა დავითვალოთ რამდენი განსხვავებული კომბინაციით შეუძლია ზურიკოს ხიდის გადალახვა.
# გადმოგვეცემა ხიდის სიგრძე და ინფორმაცია ჩატეხილ ფიცრებზე. 0 აღნიშნავს ჩატეხილ ფიცარს 1_ანი კი მთელს.
# დასაწყისისთვის ზურიკო დგას ხიდის ერთ მხარეს (არა პირველ ფიცარზე)
# და გადალახვად ჩათვლება ხიდის მეორე მხარე (ბოლო ფიცრის შემდეგი ნაბიჯი)

# როგორც ჩანს მეორე მაგალითში შეცდომაა, ვინაიდან [0, 1, 1, 0] ლისტის შემთხვევაში, ცხადია, გვაქვს გზა.

def countWaysAux(n, steps, i):
    if i + 1 == n:
        return 1
    if i + 2 == n:
        return steps[n - 1] + 1
    if steps[i+1] == 0 and steps[i+2] == 0:
        return 0
    if steps[i + 1] == 0 and steps[i + 2] == 1:
        return countWaysAux(n, steps, i + 2)
    if steps[i + 1] == 1 and steps[i + 2] == 0:
        return countWaysAux(n, steps, i + 1)
    else:
        return countWaysAux(n, steps, i + 1) + countWaysAux(n, steps, i + 2)

def countWays(n, steps):
    return countWaysAux(n, steps, -1)

# 5. გადმოგეცემათ მთელი რიცხვი N. დაწერეთ ფუნქცია რომელიც დაითვლის რამდენი 0ით ბოლოვდება N! (ფაქტორიალი)
#  	შენიშვნა 1000! შედგება 2568 სიმბოლოსაგან.

# ამ ამოცანის ამოსახსნელად უმჯობესია შევნიშნოთ რომ ის თუ რამდენი 0ით ბოლოვდება რიცხვი
# ცალსახად განისაზღვრება იმით თუ რა უდიდეს ხარისხში შეიცავს ის 10ს.
# ცხადია, რომ N! შეიცავს 2ს უფრო დიდ ხარისხში ვიდრე 5ს,
# ამიტომ საკმარისია 5ის უდიდესი ხარისხის გამოთვლა მის გაშლაში,
# ეს კი მარტივი კომბინატორული დათვლის ამოცანაა.

def zeros(N):
    cnt = 0
    i = 1
    while pow(5,i)<N:
        cnt += math.floor(N/pow(5,i))
        i += 1
    return cnt
